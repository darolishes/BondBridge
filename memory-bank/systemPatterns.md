# System Patterns & Conventions

Version: 1.3.0
Last Updated: 2025-03-26 14:48:30
Status: üü¢ Active

## Naming Conventions üìù

### Components & Files

- PascalCase f√ºr Component-Namen: `ConversationCard.tsx`, `CategoryFilter.tsx`
- PascalCase f√ºr Component-Files: `ConversationCard.tsx`, `CardDeck.tsx`
- Feature-Prefix wo sinnvoll: `Card`, `Cards`, `Conversation`
- Klare Suffixe f√ºr spezielle Component-Typen:
  - Screens: `CardsScreen.tsx`, `FavoritesScreen.tsx`
  - Stacks: `CardStack.tsx`, `SettingsStack.tsx`
  - Tests: `ConversationCard.test.tsx`, `CardDeck.test.tsx`
  - Redux: `cardsSlice.ts`, `categoriesSlice.ts`

### Functions & Variables

- camelCase f√ºr Funktionen: `handleSwipe()`, `filterCardsByCategory()`
- camelCase f√ºr Variablen: `activeCategories`, `currentCardIndex`
- Boolean-Variablen mit is/has/should Pr√§fix: `isLoading`, `hasSeenIntro`, `shouldShowFollowUp`
- Event Handler mit handle-Pr√§fix: `handleSwipe`, `handleCategorySelect`

### Files & Directories

- kebab-case f√ºr Verzeichnisse: `features/conversation-cards/`
- camelCase f√ºr Utility-Functions: `utils/animationHelpers.ts`
- PascalCase f√ºr Component-Exports: `export { ConversationCard }`

## Project Structure üèóÔ∏è

Feature-basierte Architektur mit folgendem Layout:

```
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ store.ts         # Redux store configuration
‚îÇ   ‚îú‚îÄ‚îÄ rootReducer.ts   # Root reducer
‚îÇ   ‚îî‚îÄ‚îÄ App.tsx          # Main App component
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ conversation-cards/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/  # Card-related components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/       # Custom hooks for cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screens/     # Card-related screens
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/       # Card-specific utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cards.slice.ts # Redux slice for cards
‚îÇ   ‚îî‚îÄ‚îÄ settings/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ screens/
‚îÇ       ‚îî‚îÄ‚îÄ settings.slice.ts
‚îú‚îÄ‚îÄ navigation/
‚îÇ   ‚îú‚îÄ‚îÄ AppNavigator.tsx # Main navigation container
‚îÇ   ‚îú‚îÄ‚îÄ CardStack.tsx    # Card-related navigation
‚îÇ   ‚îî‚îÄ‚îÄ SettingsStack.tsx # Settings navigation
‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îú‚îÄ‚îÄ components/      # Shared components
‚îÇ   ‚îú‚îÄ‚îÄ hooks/           # Shared hooks
‚îÇ   ‚îî‚îÄ‚îÄ utils/           # Shared utilities
‚îú‚îÄ‚îÄ theme/
‚îÇ   ‚îú‚îÄ‚îÄ ThemeProvider.tsx # Theme provider
‚îÇ   ‚îú‚îÄ‚îÄ themes.ts         # Theme definitions
‚îÇ   ‚îî‚îÄ‚îÄ useTheme.ts       # Theme hook
‚îî‚îÄ‚îÄ services/
    ‚îú‚îÄ‚îÄ storage/         # AsyncStorage services
    ‚îî‚îÄ‚îÄ api/             # API services
```

## Coding Standards üíª

### TypeScript

- Strict mode aktiviert
- Explizite Typdefinitionen f√ºr Props: `type CardProps = {...}`
- Interfaces f√ºr komplexe Datenmodelle: `interface ConversationCard {...}`
- Immutabilit√§t bevorzugen: Spread-Operator, map, filter statt direkter Mutation

### React Patterns

- Functional Components bevorzugen
- Hooks f√ºr State und Side Effects
- Custom Hooks f√ºr wiederverwendbare Logik
- Memoization f√ºr teure Berechnungen (useMemo, useCallback)

### Testing

- Jest f√ºr Unit Tests
- React Native Testing Library f√ºr Component Tests
- Mockup von Abh√§ngigkeiten wie Navigation und Redux

### Code Quality

- ESLint mit React/React Native Config
- Prettier f√ºr Codeformatierung

## State Management üß†

### Redux Toolkit

- Slices f√ºr Feature-spezifische State: `cardsSlice`, `settingsSlice`
- Selectors f√ºr State-Zugriff: `selectFilteredCards`, `selectActiveCategories`
- Thunks f√ºr Async Actions: `fetchCards`, `saveCardProgress`
- Immutability mit createSlice und immer

#### Cards Slice Pattern

```typescript
// Beispiel f√ºr cardsSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { ConversationCard, CardCategory } from "./types";

interface CardsState {
  items: ConversationCard[];
  currentCardIndex: number;
  activeCategories: CardCategory[];
  activeDifficulty: (1 | 2 | 3 | 4 | 5)[];
  favorites: string[]; // Card IDs
  history: string[]; // Card IDs
  isLoading: boolean;
  error: string | null;
}

const initialState: CardsState = {
  items: [],
  currentCardIndex: 0,
  activeCategories: [
    "icebreakers",
    "confessions",
    "personality",
    "deep-thoughts",
    "intimacy",
    "growth",
  ],
  activeDifficulty: [1, 2, 3, 4, 5],
  favorites: [],
  history: [],
  isLoading: false,
  error: null,
};

const cardsSlice = createSlice({
  name: "cards",
  initialState,
  reducers: {
    // Card Navigation Actions
    nextCard: (state) => {
      state.currentCardIndex = Math.min(
        state.currentCardIndex + 1,
        state.items.length - 1
      );
    },
    likeCard: (state, action: PayloadAction<string>) => {
      const cardId = action.payload;
      if (!state.history.includes(cardId)) {
        state.history.push(cardId);
      }
      // Weitere Logik...
    },
    skipCard: (state, action: PayloadAction<string>) => {
      // Logik f√ºr Skip...
    },
    // Category Filter Actions
    toggleCategory: (state, action: PayloadAction<CardCategory>) => {
      const category = action.payload;
      if (state.activeCategories.includes(category)) {
        state.activeCategories = state.activeCategories.filter(
          (c) => c !== category
        );
      } else {
        state.activeCategories.push(category);
      }
    },
    // Difficulty Filter Actions
    toggleDifficulty: (state, action: PayloadAction<1 | 2 | 3 | 4 | 5>) => {
      // Logik f√ºr Difficulty Toggles...
    },
    // Weitere Actions...
  },
});

// Selectors
export const selectFilteredCards = (state: RootState) => {
  const { items, activeCategories, activeDifficulty } = state.cards;
  return items.filter(
    (card) =>
      activeCategories.includes(card.category) &&
      activeDifficulty.includes(card.difficulty)
  );
};

export const {
  nextCard,
  likeCard,
  skipCard,
  toggleCategory,
  toggleDifficulty,
} = cardsSlice.actions;
export default cardsSlice.reducer;
```

### React Query

- F√ºr API-Integrationen, falls n√∂tig
- Cache-Management und Invalidierung

### Local State

- useState f√ºr isolierte Component-States
- useReducer f√ºr komplexeren lokalen State

### Persistence

- AsyncStorage f√ºr Offline-Persistenz
- Redux Persist f√ºr automatische Store-Persistenz

```typescript
// store.ts Muster mit Persistenz
import { configureStore } from "@reduxjs/toolkit";
import { persistStore, persistReducer } from "redux-persist";
import AsyncStorage from "@react-native-async-storage/async-storage";
import rootReducer from "./rootReducer";

const persistConfig = {
  key: "root",
  storage: AsyncStorage,
  whitelist: ["cards", "settings"], // Nur diese Reducer persistieren
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ["persist/PERSIST", "persist/REHYDRATE"], // F√ºr Redux Persist
      },
    }),
});

export const persistor = persistStore(store);
```

## Animation & Gesture Patterns üé¨

### Reanimated & Gesture Handler

- Reanimated 2 f√ºr performante UI-Animationen
- Gesture Handler f√ºr Touch-Interaktionen
- Worklets f√ºr JS Thread Unabh√§ngigkeit

#### Card Swipe Pattern

```typescript
// Beispiel f√ºr CardDeck mit Swipe-Funktionalit√§t
import React from "react";
import { StyleSheet, Dimensions } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
} from "react-native-reanimated";
import { PanGestureHandler } from "react-native-gesture-handler";
import type { PanGestureHandlerGestureEvent } from "react-native-gesture-handler";
import { ConversationCard } from "../components/ConversationCard";

const { width: SCREEN_WIDTH } = Dimensions.get("window");
const SWIPE_THRESHOLD = SCREEN_WIDTH * 0.3;

type CardDeckProps = {
  cards: ConversationCard[];
  onSwipeRight: (cardId: string) => void;
  onSwipeLeft: (cardId: string) => void;
};

export const CardDeck = ({
  cards,
  onSwipeRight,
  onSwipeLeft,
}: CardDeckProps) => {
  const currentCard = cards[0];
  const translateX = useSharedValue(0);
  const rotate = useSharedValue("0deg");

  // Gesture Handler Logic
  const panGestureEvent =
    useAnimatedGestureHandler<PanGestureHandlerGestureEvent>({
      onActive: (event) => {
        translateX.value = event.translationX;
        // Rotate based on swipe
        rotate.value = `${(event.translationX / SCREEN_WIDTH) * 20}deg`;
      },
      onEnd: (event) => {
        if (Math.abs(event.translationX) > SWIPE_THRESHOLD) {
          // Swipe completed
          translateX.value = withSpring(
            event.translationX > 0 ? SCREEN_WIDTH * 1.5 : -SCREEN_WIDTH * 1.5,
            {},
            () => {
              if (event.translationX > 0) {
                runOnJS(onSwipeRight)(currentCard.id);
              } else {
                runOnJS(onSwipeLeft)(currentCard.id);
              }
            }
          );
        } else {
          // Return to center
          translateX.value = withSpring(0);
          rotate.value = withSpring("0deg");
        }
      },
    });

  const cardStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value }, { rotate: rotate.value }],
    };
  });

  return (
    <PanGestureHandler onGestureEvent={panGestureEvent}>
      <Animated.View style={[styles.cardContainer, cardStyle]}>
        <ConversationCard card={currentCard} />
      </Animated.View>
    </PanGestureHandler>
  );
};

const styles = StyleSheet.create({
  cardContainer: {
    width: SCREEN_WIDTH * 0.9,
    height: SCREEN_WIDTH * 1.2,
    backgroundColor: "white",
    borderRadius: 15,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
});
```

### Animation Prinzipien

- Fl√ºssigkeit und Reaktionsgeschwindigkeit priorisieren
- Visuelle R√ºckmeldung auf Benutzerinteraktionen
- Nat√ºrliche Bewegung mit Spring-Animationen
- Leistung durch Worklets und JS-Thread-Unabh√§ngigkeit
- Animation auf der UI-Thread f√ºr Smoothness

### Gesture Patterns

- Pinch f√ºr Zoom
- Pan f√ºr Drag & Swipe
- Tap f√ºr Selection
- Double Tap f√ºr spezielle Aktionen
- Long Press f√ºr Kontextmen√ºs

## API & Data Access üì°

### API Integration

- Axios f√ºr HTTP-Anfragen
- Interceptors f√ºr Authentication
- Service-Layer f√ºr API-Zugriff

### Data-Modeling

- Typisierte Interfaces f√ºr alle Datenmodelle
- Normalisierte Daten f√ºr Redux
- Immutable Data Patterns

## Navigation üß≠

### React Navigation

- Stack Navigator f√ºr Cards & Settings
- Tab Navigator f√ºr Bottom Tabs
- Typed Navigation mit TypeScript

### Screen-Hierarchie

```
AppNavigator
‚îú‚îÄ‚îÄ BottomTabNavigator
‚îÇ   ‚îú‚îÄ‚îÄ CardStack          # Conversation Cards Flow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CardList
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CardDetail
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CardCreate
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CardEdit
‚îÇ   ‚îî‚îÄ‚îÄ SettingsStack      # Settings Flow
‚îÇ       ‚îú‚îÄ‚îÄ SettingsHome
‚îÇ       ‚îú‚îÄ‚îÄ ThemeSettings
‚îÇ       ‚îú‚îÄ‚îÄ NotificationSettings
‚îÇ       ‚îî‚îÄ‚îÄ About
‚îî‚îÄ‚îÄ AuthStack              # Auth Flow (falls n√∂tig)
    ‚îú‚îÄ‚îÄ Login
    ‚îî‚îÄ‚îÄ Register
```

## Theming üé®

### Theme System

- Context API f√ºr Theme-Provider
- Typed Theme-Definitionen
- Dark/Light Mode Support

### Colors & Styles

- Consistent Color Palette definiert in Theme
- Consistent Spacing System
- Typography Scale f√ºr konsistente Textgr√∂√üen

## Form Handling üìã

- Formik oder React Hook Form
- Yup f√ºr Schema-Validierung
- Controlled Components

## Error Handling ‚ö†Ô∏è

- Try/Catch f√ºr async/await
- Error Boundaries f√ºr React Components
- Toast-Nachrichten f√ºr User Feedback
- Error Tracking wenn m√∂glich

## Best Practices üåü

- Pure Components f√ºr bessere Performance
- Memoization f√ºr teure Berechnungen
- Code-Splitting wo sinnvoll
- Lazy Loading f√ºr bessere Startup-Performance
- Typesafety durch TypeScript
